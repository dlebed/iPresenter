#ifndef ISERIALPORTIO_H
#define ISERIALPORTIO_H

extern "C" {
#include <stdint.h>
#include <unistd.h>
}

#include <defines.h>

//! Интерфейс класса для работы с последовательным портом
/*!
  Обеспечивает работу с последовательным портом.
  Имеет возможность установки межсимвольных таймаутов.
  \note Параметры устанавливаются при помощи методов setSpeed(), setDataBits(),
  setStopBits(), setParity(), setFlowControl().
  Применяются же они к устройству только после вызова метода setSettings().
  */

class ISerialPortIO {
public:

        //! Количество бит данных
        enum DataBitsType {
                //! 5 бит данных
                DATA_5,
                //! 6 бит данных
                DATA_6,
                //! 7 бит данных
                DATA_7,
                //! 8 бит данных
                DATA_8
        };

        //! Количество стоп-бит
        enum StopBitsType {
                //! 1 стоп-бит
                STOP_1,
                //! 2 стоп-бита
                STOP_2
        };

        //! Тип контроля чётности
        enum ParityType {
                //! Без контроля чётности
                PAR_NONE,
                //! Контроль чётности с дополнением до нечетного
                PAR_ODD,
                //! Контроль чётности с дополнением до четного
                PAR_EVEN
        };

        //! Тип управления потоком
        enum FlowControlType {
                //! Без управления потоком
                FLOW_OFF,
                //! Аппаратный RTS/CTS контроль передачи
                FLOW_HARDWARE,
                //! Программный XON/XOFF контроль передачи
                FLOW_XONXOFF
        };
    
        //! Тип для указания какие буферы сбрасывать
        enum FlushType {
            //! Буфер приёма
            FLUSH_INPUT         =   0,
            //! Буфер отправки
            FLUSH_OUTPUT        =   1,
            //! Буфер приёма и буфер отправки
            FLUSH_INPUT_OUTPUT  =   2
        };
        
        enum Flags {
            //! Работа порта с низкими задержками
            LOW_LATENCY         =   1 << 0
        };

	//! Конструктор без открытия порта
	ISerialPortIO() {};

	//! Конструктор с открытием порта
	ISerialPortIO(const char *) {};

	virtual ~ISerialPortIO() {};

	//! Открытие устройства и применение настроек по умолчанию
    /*!
     \param pathname путь к устройству последовательного порта
     \return значение >= нуля в случае успеха, значение меньше нуля в случае ошибки.
     */
	virtual int open(const char *pathname) = 0;

    //! Получить описание последней ошибки
    //virtual char * lastErrorStr() const = 0;
    
	//! Закрытие устройства
	virtual int close() = 0;

	//! Проверка, открыт ли порт
	virtual bool isOpen() const = 0;

	//! Установка скорости порта
    /*!
     * Изменение скорости обмена вступает в силу только после вызова функции setSettings().
     * Значение скорости по умолчнию - 9600.
     * \param speed целочисленное значение скорости порта
     * \return ноль - в случае успеха, значение меньше нуля - в случае невозможности преобразования
      */
	virtual int setSpeed(uint32_t speed) = 0;

    //! Установка количества бит данных для порта
    /*!
      * Изменение количества бит данных вступает в силу только после вызова функции setSettings().
      * Значение по умолчанию: 8 бит данных.
      */
	virtual void setDataBits(DataBitsType DataBits) = 0;

	//! Установка количества стоп-бит для порта
    /*!
      * Изменение количества стоп-бит вступает в силу только после вызова функции setSettings().
      * Значение по умолчанию: 1 стоп-бит.
      */
	virtual void setStopBits(StopBitsType StopBits) = 0;

	//! Установка типа четности для порта
    /*!
     * Изменение параметров четности порта вступает в силу только после вызова функции setSettings().
     * Значение по умолчанию: проверка и генерация бита чётности отключена.
      */
	virtual void setParity(ParityType Parity) = 0;

	//! Установка типа управления потоком
    /*!
      * Изменение параметров управления потоком вступает в силу только после вызова функции setSettings().
      * Значение по умолчанию: контроль управления потоком отключен.
      */
	virtual void setFlowControl(FlowControlType FlowControl) = 0;

	//! Установка значения таймаута для операции чтения
	/*!
     * Данная функция задает таймаут появления данных в приемном буфере UART.
     * Изменения вступают в силу немедленно.
	 * \param timeout значение таймаута в микросекундах
	 * \return результат выполнения операции, 0 в случае успеха, значение меньше нуля в случае ошибки.
	 */
	virtual int setReadTimeout(uint32_t timeout) = 0;
	
	//! Установка значения межбайтного таймаута для операции чтения
	/*!
     * Данная функция устанавливает межбайтовый таймаут для операции чтения.
     * После получения первой порции данных (при первом вызове функции read())
     * начинает работать межбайтовый таймаут. Если в течении него не получено
     * ни одного байта, то операция чтения завершается.
     * Изменения вступают в силу немедленно.
	 * \param timeout таймаут в микросекундах
     * \return результат выполнения операции, 0 в случае успеха, значение меньше нуля в случае ошибки.
	 */
	virtual int setInterByteTimeout(uint32_t timeout) = 0;

	//! Установка необходимого количества байт для чтения
	/*!
	 * Изменения данного параметра вступают в силу немедленно.
     * После установки данного значения функция read не завершится, пока не будет прочитано count байт.
	 * \param count необходимое количество байт
	 */
	virtual int setReadCount(uint32_t count) = 0;

	//! Установка необходимого таймаута для операции записи
	/*!
	 * Изменения данного параметра вступают в силу немедленно.
	 * \param count необходимое количество байт
	 */
	virtual void setWriteTimeout(uint32_t count) = 0;

	//! Применение настроек
	/*!
	 * Применяет настройки последовательного порта, выставленные функциями setSpeed(), setDataBits(),
     * setStopBits(), setParity(), setFlowControl().
	 * \return 0 в случае успеха, < 0 в случае неудачи
	 */
	virtual int setSettings() = 0;

	//! Удаляет незаписанные, или несчитанные данные из буфера порта
	/*!
	 * \param type TCIFLUSH - для очистки принятых, но не прочитанных данных,\n
	 * TCOFLUSH - для очистки записанных в буфер порта данных, но не переданных\n
	 * TCIOFLUSH - для очистки обеих буферов, приёма и передачи
	 */
	virtual int flush(FlushType type = FLUSH_INPUT) = 0;
    
    //! Ожидане окончания передачи записанных данных
    /*!
     * Выход из данной функции происходит только тогда, когда все записанные в буфер последовательного
     * порта данные будут переданы в линию.
      */
    virtual int drain() = 0;

	//! Закрыть все открытиые при помощи данного класса файловые дескрипторы
	virtual void closeAllFDs() = 0;

	//! Прочитать из порта
	/*!
	 * Функция записи в порта без работы с таймаутами
	 * \param data указатель на буфер с данными
	 * \param size размер записываемых данных в байтах
	 */
	virtual ssize_t write(uint8_t *data, size_t size) = 0;

	//! Записать в порт
	/*!
	 * Функция чтения из порта с установленным по умолчанию таймаутом.
     * Таймаут по умолчанию задается при помощи функции setReadTimeout.
     * \param data указатель на буфер для принятых данных (размера >= size)
	 * \param size размер ожидаемых данных в байтах
     * \return размер принятых данных в байтах (больше ноля), ноль - в случае истечения таймаута и отсутствии принятых данных,
     *         значение меньше нуля в случае ошибки.
     * \sa setReadTimeout()
	 */
	virtual ssize_t read(uint8_t *data, size_t size) = 0;

	//! Прочитать из порта с установкой таймаута
	/*!
	 * Функция чтения из порта с установкой таймаута. После вызова
	 * Параметр timeout задаёт максимальное время ожидания появления данных в приёмном буфере порта.
	 * Межбайтовый таймаут для операции чтения задаётся при помощи функции setInterByteTimeout.
	 * \param data указатель на буфер для принятых данных (размера >= size)
	 * \param size размер ожидаемых данных в байтах
	 * \param timeout значение нового таймаута начала передачи для операции чтения в микросекундах
	 * \return размер принятых данных в байтах (больше ноля), ноль - в случае истечения таймаута и отсутствии принятых данных,
     *         значение меньше нуля в случае ошибки.
	 * \sa setInterByteTimeout(), read(), setReadTimeout()
	 */
	virtual ssize_t read(uint8_t *data, size_t size, uint32_t timeout) = 0;

};

#endif // ISERIALPORTIO_H
